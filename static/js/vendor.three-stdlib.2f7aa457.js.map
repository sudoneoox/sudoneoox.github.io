{"version":3,"file":"static/js/vendor.three-stdlib.2f7aa457.js","mappings":"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","sources":["../node_modules/src/controls/EventDispatcher.ts","../node_modules/src/controls/OrbitControls.ts","../node_modules/src/misc/WebGL.ts"],"sourcesContent":["/*\nDue to @types/three r168 breaking change\nwe have to manually copy the EventDispatcher class from three.js.\nSo this files merges the declarations from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/three/src/core/EventDispatcher.d.ts\nwith the implementation from https://github.com/mrdoob/three.js/blob/dev/src/core/EventDispatcher.js\nMore info in https://github.com/pmndrs/three-stdlib/issues/387\n*/\n\n/**\n * The minimal basic Event that can be dispatched by a {@link EventDispatcher<>}.\n */\nexport interface BaseEvent<TEventType extends string = string> {\n    readonly type: TEventType;\n    // not defined in @types/three\n    target: any;\n}\n\n/**\n * The minimal expected contract of a fired Event that was dispatched by a {@link EventDispatcher<>}.\n */\nexport interface Event<TEventType extends string = string, TTarget = unknown> {\n    readonly type: TEventType;\n    readonly target: TTarget;\n}\n\nexport type EventListener<TEventData, TEventType extends string, TTarget> = (\n    event: TEventData & Event<TEventType, TTarget>,\n) => void;\n\nexport class EventDispatcher<TEventMap extends {} = {}> {\n    // not defined in @types/three\n    private _listeners: any;\n\n    /**\n     * Adds a listener to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n\taddEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\t/**\n     * Checks if listener is added to an event type.\n     * @param type The type of event to listen to.\n     * @param listener The function that gets called when the event is fired.\n     */\n    hasEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): boolean {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\t/**\n     * Removes a listener from an event type.\n     * @param type The type of the listener that gets removed.\n     * @param listener The listener function that gets removed.\n     */\n    removeEventListener<T extends Extract<keyof TEventMap, string>>(\n        type: T,\n        listener: EventListener<TEventMap[T], T, this>,\n    ): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n     * Fire an event type.\n     * @param event The event that gets fired.\n     */\n    dispatchEvent<T extends Extract<keyof TEventMap, string>>(event: BaseEvent<T> & TEventMap[T]): void {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}","import {\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\nimport { EventDispatcher } from './EventDispatcher'\nimport { StandardControlsEventMap } from './StandardControlsEventMap'\n\nconst _ray = /* @__PURE__ */ new Ray()\nconst _plane = /* @__PURE__ */ new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher<StandardControlsEventMap> {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n  // Not used in most scenarios, however they can be useful for specific use cases\n  getZoomScale: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  // Dolly in programmatically\n  dollyIn: (dollyScale?: number) => void\n  // Dolly out programmatically\n  dollyOut: (dollyScale?: number) => void\n  // Get the current scale\n  getScale: () => number\n  // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n  setScale: (newScale: number) => void\n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function setScale(newScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale = newScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyOut(dollyScale: number) {\n      setScale(scale / dollyScale)\n    }\n\n    function dollyIn(dollyScale: number) {\n      setScale(scale * dollyScale)\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // Add dolly in/out methods for public API\n\n    this.dollyIn = (dollyScale = getZoomScale()) => {\n      dollyIn(dollyScale)\n      scope.update()\n    }\n\n    this.dollyOut = (dollyScale = getZoomScale()) => {\n      dollyOut(dollyScale)\n      scope.update()\n    }\n\n    this.getScale = () => {\n      return scale\n    }\n\n    this.setScale = (newScale) => {\n      setScale(newScale)\n      scope.update()\n    }\n\n    this.getZoomScale = () => {\n      return getZoomScale()\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n","let webGLAvailable: boolean, webGL2Available: boolean\n\nexport function isWebGLAvailable(): boolean {\n  if (webGLAvailable !== undefined) return webGLAvailable\n  try {\n    let gl\n    const canvas = document.createElement('canvas')\n    webGLAvailable = !!(window.WebGLRenderingContext && (gl = canvas.getContext('webgl')))\n    if (gl) gl.getExtension('WEBGL_lose_context')?.loseContext()\n    return webGLAvailable\n  } catch (e) {\n    return (webGLAvailable = false)\n  }\n}\n\nexport function isWebGL2Available(): boolean {\n  if (webGL2Available !== undefined) return webGL2Available\n  try {\n    let gl\n    const canvas = document.createElement('canvas')\n    webGL2Available = !!(window.WebGL2RenderingContext && (gl = canvas.getContext('webgl2')))\n    if (gl) gl.getExtension('WEBGL_lose_context')?.loseContext()\n    return webGL2Available\n  } catch (e) {\n    return (webGL2Available = false)\n  }\n}\n\nexport function getWebGLErrorMessage(): HTMLDivElement {\n  return getErrorMessage(1)\n}\n\nexport function getWebGL2ErrorMessage(): HTMLDivElement {\n  return getErrorMessage(2)\n}\n\nexport function getErrorMessage(version: 1 | 2): HTMLDivElement {\n  const names = {\n    1: 'WebGL',\n    2: 'WebGL 2',\n  }\n\n  const contexts = {\n    1: window.WebGLRenderingContext,\n    2: window.WebGL2RenderingContext,\n  }\n\n  const element = document.createElement('div')\n  element.id = 'webglmessage'\n  element.style.fontFamily = 'monospace'\n  element.style.fontSize = '13px'\n  element.style.fontWeight = 'normal'\n  element.style.textAlign = 'center'\n  element.style.background = '#fff'\n  element.style.color = '#000'\n  element.style.padding = '1.5em'\n  element.style.width = '400px'\n  element.style.margin = '5em auto 0'\n\n  let message =\n    'Your $0 does not seem to support <a href=\"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation\" style=\"color:#000\">$1</a>'\n\n  if (contexts[version]) {\n    message = message.replace('$0', 'graphics card')\n  } else {\n    message = message.replace('$0', 'browser')\n  }\n\n  message = message.replace('$1', names[version])\n  element.innerHTML = message\n  return element\n}\n"],"names":["EventDispatcher","constructor","__publicField","addEventListener","type","listener","this","_listeners","listeners","indexOf","push","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","event","target","array","slice","i","l","length","call","_ray","Ray","_plane","Plane","TILT_LIMIT","Math","cos","PI","moduloWrapAround","offset","capacity","OrbitControls","object","domElement","Vector3","Infinity","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","target0","clone","position0","position","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","theta","setPolarAngle","value","currentPhi","phiDist","abs","sphericalDelta","scope","update","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","saveState","copy","reset","updateProjectionMatrix","changeEvent","state","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","min","minAzimuthAngle","max","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","add","zoomToCursor","performCursorZoom","isOrthographicCamera","radius","clampDistance","scale","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","set","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","x","y","unproject","minZoom","maxZoom","mouseAfter","console","warn","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","OrthographicCamera","distanceToSquared","EPS","quaternion","connect","style","touchAction","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","dispose","_a","_b","_c","_d","_e","ownerDocument","onPointerMove","_f","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","pow","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","v","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","right","left","clientWidth","top","bottom","enablePan","setScale","newScale","enableZoom","dollyOut","dollyScale","dollyIn","updateMouseParameters","rect","getBoundingClientRect","clientX","clientY","w","width","h","height","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","pointerId","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","needsUpdate","code","keys","keyPanSpeed","handleKeyDown","pointer","arguments","undefined","getScale","webGL2Available","isWebGL2Available","gl","canvas","document","createElement","window","WebGL2RenderingContext","getContext","getExtension","loseContext","e"],"sourceRoot":""}